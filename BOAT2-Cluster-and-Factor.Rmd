---
title: "Building Owners' Decision-Making Profile Clustering and Factor Analysis"
subtitle: "Building Owners' Decision-Making Profile Clustering and Factor Analysis"
author: "Researcher"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: cosmo
    highlight: tango
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Project Overview

This research aims to analyze building owners' decision-making characteristics, identify owner decision-making patterns through cluster analysis, and explore the relationship between these patterns and project delivery methods (PDM). The study employs multiple clustering methods and dimensionality reduction techniques for visualization to identify groups of owners with similar decision-making characteristics.

## Research Questions

1. Are there distinct grouping patterns in building owners' decision-making characteristics?
2. How do different clustering methods perform in distinguishing owner decision-making characteristics?
3. Is there an association between owner decision-making characteristics and project delivery methods?
4. Which decision-making characteristics are most important in distinguishing different owner groups?

## Analysis Methods

This study employs three main clustering methods:
- Hierarchical Clustering
- Partitioning Around Medoids (PAM)
- K-Prototypes Clustering - for handling mixed data types

And determines the optimal number of clusters through:
- Silhouette Analysis
- Elbow Method
- Gap Statistic
- Cluster Stability Analysis

# Preparation

## Load Required Libraries
```{r libraries}
# Data processing libraries
library(tidyverse)  # Comprehensive package for data processing and visualization
library(dplyr)      # Data manipulation and transformation
library(readr)      # Efficient text data reading

# Visualization libraries
library(ggplot2)    # Declarative graphics creation
library(gridExtra)  # Combine multiple ggplot graphics
library(scales)     # Graphic scaling and labels
library(viridis)    # Colorblind-friendly palette
library(RColorBrewer) # Classic color palettes
library(ggrepel)    # Non-overlapping text labels
library(factoextra) # PCA result visualization
library(grid)       # Base graphics system
library(gridExtra)  # Grid graphics extension

# Clustering analysis libraries
library(cluster)    # Clustering algorithms and analysis
library(clustMixType) # Mixed data type clustering
library(NbClust)    # Determine optimal number of clusters
library(dendextend) # Dendrogram enhancement and visualization
library(mclust)     # Model-based clustering and adjustedRandIndex function

# Dimensionality reduction libraries
library(umap)       # Non-linear dimensionality reduction
```

# Data Import and Exploration

## Data Import and Initial Processing
```{r data_import}
# Read raw data
raw_data <- read.csv("BOAT2_Data.csv")

# Add unique ID
raw_data$ID <- 1:nrow(raw_data)

# Data overview
str(raw_data)
summary(raw_data)

# Check missing values
missing_values <- colSums(is.na(raw_data))
print("Number of missing values for each variable:")
print(missing_values[missing_values > 0])
```

## Exploratory Data Analysis
```{r exploratory}
# Check outliers - Organizational structure characteristics
par(mfrow=c(2, 2))
boxplot(raw_data$Org_Structure_Employees, main="Number of Employees", col="lightblue")
boxplot(raw_data$Org_Structure_Locations, main="Number of Locations", col="lightgreen")
boxplot(raw_data$Org_Structure_Depts, main="Number of Departments", col="lightpink")
boxplot(raw_data$Org_Structure_Layers, main="Number of Hierarchical Layers", col="lightyellow")

# Main project delivery method distribution
pdm_counts <- table(raw_data$PDM_Type)
pdm_perc <- prop.table(pdm_counts) * 100

# Visualize project delivery method distribution
ggplot(data.frame(PDM = names(pdm_counts), Count = as.numeric(pdm_counts)), 
       aes(x = reorder(PDM, -Count), y = Count, fill = PDM)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(as.numeric(pdm_perc), 1), "%")), 
            vjust = -0.5, size = 3) +
  labs(title = "Project Delivery Method Distribution",
       x = "Project Delivery Method",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "none")
```

# Data Preprocessing

## Define Variable Groups
```{r variables_definition}
# 1. Numerical organizational characteristic variables
numerical_org_vars <- c(
  "Org_Structure_Employees",
  "Org_Structure_Locations",
  "Org_Structure_Depts",
  "Org_Structure_Layers"
)

# 2. Single ordinal decision characteristic variables
ordinal_single_vars <- c(
  "Style_Technocracy", 
  "Culture_Command", 
  "Culture_Symbolic", 
  "Culture_Rationale", 
  "Culture_Generative", 
  "Culture_Transactive",
  "Flexibility_openness", 
  "Flexibility_Recursiveness",
  "Risk",
  "Environment_Growth", 
  "Environment_Hostile", 
  "Environment_Stable"
)

# 3. Multiple ordinal decision characteristic variable pairs
ordinal_multi_vars <- list(
  Distribution_Centralization = c("Distribution_Centralization1", "Distribution_Centralization2"),
  Distribution_Formalization = c("Distribution_Formalization1", "Distribution_Formalization2"),
  Style_Participation = c("Style_Participation1", "Style_Participation2"),
  Style_Organicity = c("Style_Organicity1", "Style_Organicity2"),
  Style_Coercion = c("Style_Coercion1", "Style_Coercion2")
)

# 4. All original ordinal decision characteristic variables
ordinal_all_vars <- c(
  unlist(ordinal_multi_vars),
  ordinal_single_vars
)

# 5. Categorical variables
categorical_vars <- c(
  "PDM_Type"
)
```

## Create Merged Variable Dataset
```{r create_merged_dataset}
# Calculate means for multiple constructs
merged_data <- raw_data %>%
  mutate(
    # Calculate means for multiple constructs
    Distribution_Centralization = (Distribution_Centralization1 + Distribution_Centralization2) / 2,
    Distribution_Formalization = (Distribution_Formalization1 + Distribution_Formalization2) / 2,
    Style_Participation = (Style_Participation1 + Style_Participation2) / 2,
    Style_Organicity = (Style_Organicity1 + Style_Organicity2) / 2,
    Style_Coercion = (Style_Coercion1 + Style_Coercion2) / 2
  )

# Merged ordinal decision variables
merged_ordinal_vars <- c(
  "Distribution_Centralization", 
  "Distribution_Formalization",
  "Style_Technocracy", 
  "Style_Participation", 
  "Style_Organicity", 
  "Style_Coercion",
  "Culture_Command", 
  "Culture_Symbolic", 
  "Culture_Rationale", 
  "Culture_Generative", 
  "Culture_Transactive",
  "Flexibility_openness", 
  "Flexibility_Recursiveness",
  "Risk",
  "Environment_Growth", 
  "Environment_Hostile", 
  "Environment_Stable"
)

# Create dataset for hierarchical clustering
merged_cluster_data <- merged_data %>%
  select(
    ID, 
    all_of(merged_ordinal_vars),
    PDM_Type
  )
```

## Create Original Variable Dataset
```{r create_original_dataset}
# Remove outliers (record with 3700 employees)
original_data <- raw_data %>%
  filter(Org_Structure_Employees != 3700)

# Prepare data for K-prototype clustering
original_cluster_data <- original_data %>%
  select(
    ID,
    all_of(numerical_org_vars),
    all_of(ordinal_all_vars),
    PDM_Type
  )
```

## Handle Missing Values
```{r handle_missing}
# Handle missing values in merged variable dataset - using means
merged_cluster_data <- merged_cluster_data %>%
  mutate(across(where(is.numeric), ~ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# Display comparison before and after handling missing values
print("Merged variable dataset - Before handling missing values:")
print(colSums(is.na(merged_data[, merged_ordinal_vars])))
print("Merged variable dataset - After handling missing values:")
print(colSums(is.na(merged_cluster_data[, merged_ordinal_vars])))

# Handle missing values in original variable dataset - using medians
original_vars_for_cluster <- c(numerical_org_vars, ordinal_all_vars)
original_cluster_vars <- original_data %>%
  select(all_of(original_vars_for_cluster))

print("Original variable dataset - Before handling missing values:")
print(colSums(is.na(original_cluster_vars)))

# Handle missing values
original_cluster_vars <- original_cluster_vars %>%
  mutate(across(everything(), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))

print("Original variable dataset - After handling missing values:")
print(colSums(is.na(original_cluster_vars)))
```

## Data Preparation and Initial Clustering Analysis
This section focuses on preparing the data and performing hierarchical clustering analysis to identify distinct groups of building owners based on their decision-making profiles.

```{r}
# Read the data
boat_data <- read.csv("BOAT2_Data.csv")

# Create a unique ID for each observation
boat_data$ID <- 1:nrow(boat_data)

# Extract and process the decision-making profile characteristics
dmpc_data <- boat_data %>%
  # Calculate mean values for multi-item constructs
  mutate(
    Distribution_Centralization = (Distribution_Centralization1 + Distribution_Centralization2) / 2,
    Distribution_Formalization = (Distribution_Formalization1 + Distribution_Formalization2) / 2,
    Style_Participation = (Style_Participation1 + Style_Participation2) / 2,
    Style_Organicity = (Style_Organicity1 + Style_Organicity2) / 2,
    Style_Coercion = (Style_Coercion1 + Style_Coercion2) / 2
  ) %>%
  # Select the variables for clustering
  select(
    ID, 
    Distribution_Centralization, Distribution_Formalization,
    Style_Technocracy, Style_Participation, Style_Organicity, Style_Coercion,
    Culture_Command, Culture_Symbolic, Culture_Rationale, Culture_Generative, Culture_Transactive,
    Flexibility_openness, Flexibility_Recursiveness,
    Risk,
    Environment_Growth, Environment_Hostile, Environment_Stable,
    PDM_Type
  )

# Handle missing values
dmpc_data <- dmpc_data %>%
  mutate(across(where(is.numeric), ~ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# Extract PDM_Type for later use
pdm_types <- dmpc_data$PDM_Type
ids <- dmpc_data$ID

# Prepare data for clustering (only numeric variables)
dmpc_matrix <- dmpc_data %>%
  select(-ID, -PDM_Type) %>%
  as.matrix()

# Scale the data
dmpc_scaled <- scale(dmpc_matrix)
rownames(dmpc_scaled) <- ids

# Compute distance matrix
dist_matrix <- dist(dmpc_scaled, method = "euclidean")

# Perform hierarchical clustering using Ward's method
# Ward's method tends to create more balanced, interpretable clusters
hc_ward <- hclust(dist_matrix, method = "ward.D2")

# Create a dendrogram object
dend <- as.dendrogram(hc_ward)

# Define color palette for PDM types
pdm_colors <- brewer.pal(length(unique(pdm_types)), "Set1")
names(pdm_colors) <- unique(pdm_types)

# Color the labels based on PDM type
pdm_colors_mapped <- pdm_colors[pdm_types]
labels_colors(dend) <- pdm_colors_mapped[order.dendrogram(dend)]

# Set up the plot with larger dimensions and margins
pdf("BOAT2_Dendrogram_PDM.pdf", width = 12, height = 8)
par(mar = c(8, 4, 4, 10))  # Bottom, left, top, right margins

# Plot the dendrogram
plot(dend,
     main = "Hierarchical Clustering of Building Owners by Decision-Making Profiles",
     sub = "Colored by Project Delivery Method (PDM)",
     xlab = "",
     ylab = "Height (Dissimilarity)",
     horiz = FALSE,
     axes = TRUE,
     cex = 0.7,
     leaflab = "none")  # Don't show default labels

# Add custom colored labels at the bottom
labels <- labels(dend)
pdm_label_colors <- pdm_colors_mapped[order.dendrogram(dend)]
text(1:length(labels), 
     par("usr")[3] - 0.1,  # Position below axis
     labels = labels, 
     col = pdm_label_colors,
     srt = 90,  # Rotate text 90 degrees
     adj = 1,   # Align to right
     cex = 0.6, # Text size
     xpd = TRUE)  # Allow plotting outside figure region

# Add a legend for PDM types
legend("topright", 
       legend = names(pdm_colors),
       fill = pdm_colors,
       title = "Project Delivery Method",
       cex = 0.8,
       bg = "white",
       xpd = TRUE)

# Cut the tree to get 3 clusters (adjust based on your analysis)
k <- 3  # Number of clusters
rect.hclust(hc_ward, k = k, border = 2:(k+1))

# Add cluster labels
clusters <- cutree(hc_ward, k = k)
cluster_centers <- tapply(1:length(clusters), clusters, mean)
text(cluster_centers, par("usr")[4] - 5, 
     labels = paste("Cluster", 1:k), 
     cex = 1.2, 
     font = 2,
     col = 2:(k+1),
     xpd = TRUE)

dev.off()

# Additionally create a dendrogram with branches colored by clusters
dend_colored <- color_branches(dend, k = k)

# Create a second plot with branches colored by cluster
pdf("BOAT2_Dendrogram_Clusters.pdf", width = 12, height = 8)
par(mar = c(8, 4, 4, 10))

plot(dend_colored,
     main = "Hierarchical Clustering of Building Owners by Decision-Making Profiles",
     sub = "Branches Colored by Cluster Assignment",
     xlab = "",
     ylab = "Height (Dissimilarity)",
     horiz = FALSE,
     axes = TRUE,
     leaflab = "none")

# Add cluster rectangles
rect.hclust(hc_ward, k = k, border = 2:(k+1))

# Add cluster labels
text(cluster_centers, par("usr")[4] - 5, 
     labels = paste("Cluster", 1:k), 
     cex = 1.2, 
     font = 2,
     col = 2:(k+1),
     xpd = TRUE)

# Optional: Add PDM labels at the bottom
text(1:length(labels), 
     par("usr")[3] - 0.1,
     labels = labels, 
     col = pdm_label_colors,
     srt = 90,
     adj = 1,
     cex = 0.6,
     xpd = TRUE)

dev.off()

# Output cluster assignments with PDM types
cluster_pdm <- data.frame(
  ID = ids[order.dendrogram(dend)],
  PDM_Type = pdm_types[order.dendrogram(dend)],
  Cluster = clusters[order.dendrogram(dend)]
)

# Save the cluster assignments
write.csv(cluster_pdm, "BOAT2_Cluster_Assignments.csv", row.names = FALSE)

# Create a contingency table of PDM types by cluster
pdm_cluster_table <- table(pdm_types, clusters)
print(pdm_cluster_table)

# Calculate percentages within each cluster
pdm_cluster_percent <- prop.table(pdm_cluster_table, margin = 2) * 100
print(round(pdm_cluster_percent, 1))

# Save the contingency table
write.csv(pdm_cluster_table, "BOAT2_PDM_Cluster_Table.csv")
```

## K-Prototypes Clustering Analysis
本节实现了K-prototypes聚类，适用于处理混合数据类型（数值型和分类型变量），并比较不同的聚类解决方案。

### 数据准备
```{r kproto_data_prep}
# Dataset preparation for K-Prototypes clustering
kproto_data <- original_cluster_vars

# Display data structure
str(kproto_data)

# Create mixed dataset for K-Prototypes
kproto_data_mixed <- kproto_data
# Convert ordinal variables to ordered factors
kproto_data_mixed[ordinal_all_vars] <- lapply(
  kproto_data_mixed[ordinal_all_vars], 
  function(x) ordered(round(x), levels = 1:5)
)

# Calculate Gower distance matrix (suitable for mixed data types)
kproto_gower_dist <- daisy(kproto_data_mixed, metric = "gower")
```

### Determining Optimal Number of Clusters

#### 1. Silhouette Analysis (using Gower Distance)
```{r kproto_silhouette}
# Set maximum number of clusters
kproto_max_k <- 8
kproto_sil_width <- numeric(kproto_max_k - 1)

# For different k values, create clusters using PAM algorithm and calculate silhouette coefficients
for(k in 2:kproto_max_k) {
  pam_fit <- pam(kproto_gower_dist, k = k, diss = TRUE)
  kproto_sil_width[k-1] <- pam_fit$silinfo$avg.width
}

# Plot silhouette width
kproto_silhouette_plot <- ggplot(
  data.frame(k = 2:kproto_max_k, sil_width = kproto_sil_width), 
  aes(x = k, y = sil_width)
) +
  geom_line() +
  geom_point() +
  labs(title = "Silhouette Analysis based on Gower Distance",
       x = "Number of Clusters (k)",
       y = "Average Silhouette Width") +
  theme_minimal()

print(kproto_silhouette_plot)

# Display optimal k value (based on maximum silhouette width)
kproto_best_k_sil <- which.max(kproto_sil_width) + 1
cat("Optimal number of clusters based on silhouette analysis:", kproto_best_k_sil, "\n")
```

#### 2. Elbow Method (using K-Prototypes)
```{r kproto_elbow}
# Set random seed for reproducibility
set.seed(123)

# 定义要测试的k值范围
k_values <- 2:kproto_max_k

# 初始化WSS向量
kproto_wss <- numeric(length(k_values))

# 计算各k值的WSS
for(i in seq_along(k_values)) {
  k <- k_values[i]
  kproto_result <- kproto(kproto_data_mixed, k = k, verbose = FALSE)
  kproto_wss[i] <- kproto_result$tot.withinss
}

# 找出基于肘部法则的最佳k值
# 可以使用简单的视觉判断或二阶差分方法
k_diff <- diff(diff(kproto_wss))
kproto_best_k_elbow <- k_values[which(k_diff > 0)[1] + 1]
if(is.na(kproto_best_k_elbow)) {
  kproto_best_k_elbow <- 3  # 基于视觉判断的默认值
}

# 视觉最佳k值
kproto_best_k_visual <- 7

# 创建肘部图
kproto_elbow_plot <- ggplot(
  data.frame(k = k_values, wss = kproto_wss), 
  aes(x = k, y = wss)
) +
  geom_line() +
  geom_point(size = 3) +
  # 添加视觉最佳k值的标记
  geom_vline(xintercept = kproto_best_k_visual, linetype = "dashed", color = "red") +
  annotate("text", x = kproto_best_k_visual + 0.3, 
           y = min(kproto_wss) + (max(kproto_wss) - min(kproto_wss)) * 0.1, 
           label = paste("Best k =", kproto_best_k_visual), 
           color = "red") +
  labs(title = "K-Prototypes Elbow Plot",
       x = "Number of Clusters (k)",
       y = "Total Within-Cluster Sum of Squares") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  ) +
  scale_x_continuous(breaks = k_values)

# 显示图表
print(kproto_elbow_plot)

ggsave("Results/BOAT2_Elbow_Plot.pdf", plot = kproto_elbow_plot, width = 8, height = 6)
```

#### 3. Gap Statistic
```{r kproto_gap}
# Calculate Gap statistic using clusGap function
# Note: This may require significant computation time
kproto_gap_stat <- clusGap(
  kproto_data, 
  FUN = pam, 
  K.max = kproto_max_k, 
  B = 50  # B is the number of bootstrap samples, can be set higher in production
)

# Plot Gap statistic
kproto_gap_plot <- ggplot(
  data.frame(
    k = 1:kproto_max_k, 
    gap = kproto_gap_stat$Tab[,"gap"], 
    se = kproto_gap_stat$Tab[,"SE.sim"]
  ), 
  aes(x = k, y = gap)
) +
  geom_line() +
  geom_point() +
  geom_errorbar(aes(ymin = gap - se, ymax = gap + se), width = 0.1) +
  labs(title = "Gap Statistic Analysis",
       x = "Number of Clusters (k)",
       y = "Gap Statistic (with SE)") +
  theme_minimal()

print(kproto_gap_plot)

# Determine optimal k using firstSEmax method
kproto_best_k_gap <- maxSE(
  kproto_gap_stat$Tab[,"gap"], 
  kproto_gap_stat$Tab[,"SE.sim"], 
  method = "firstSEmax"
)
cat("Optimal number of clusters based on Gap statistic:", kproto_best_k_gap, "\n")
```

#### 4. Cluster Stability Analysis
```{r kproto_stability}
# Set random seed
set.seed(456)

# Perform multiple sampling and clustering to assess stability
kproto_n_samples <- 10
kproto_stability_results <- data.frame(k = integer(), ari = numeric())

for(k in 2:5) {  # Focus on k=2 to k=5
  ari_values <- numeric(kproto_n_samples)
  
  for(i in 1:kproto_n_samples) {
    # Randomly sample 80% of the data
    sample_idx <- sample(1:nrow(kproto_data_mixed), 
                         size = floor(0.8 * nrow(kproto_data_mixed)))
    sample_data <- kproto_data_mixed[sample_idx, ]
    
    # Cluster the sampled data
    kproto_sample <- kproto(sample_data, k = k, verbose = FALSE)
    
    # Cluster the full data
    kproto_full <- kproto(kproto_data_mixed, k = k, verbose = FALSE)
    
    # Calculate Adjusted Rand Index (ARI)
    # Note: We can only compare observations in the sample
    # adjustedRandIndex function is from mclust package
    common_idx <- sample_idx
    ari <- adjustedRandIndex(kproto_sample$cluster, 
                             kproto_full$cluster[common_idx])
    ari_values[i] <- ari
  }
  
  kproto_stability_results <- rbind(
    kproto_stability_results, 
    data.frame(k = k, ari = mean(ari_values))
  )
}

# Plot stability results
kproto_stability_plot <- ggplot(kproto_stability_results, 
                               aes(x = k, y = ari)) +
  geom_line() +
  geom_point() +
  labs(title = "Cluster Stability Analysis",
       x = "Number of Clusters (k)",
       y = "Average Adjusted Rand Index (ARI)") +
  ylim(0, 1) +
  theme_minimal()

print(kproto_stability_plot)

# Output stability results for each k value
cat("Cluster stability for each k value (based on Adjusted Rand Index):\n")
print(kproto_stability_results)

# Determine optimal k value (based on highest stability)
kproto_best_k_stability <- kproto_stability_results$k[
  which.max(kproto_stability_results$ari)
]
cat("Optimal number of clusters based on stability analysis:", kproto_best_k_stability, "\n")
```

#### 5. Combined Evaluation of Optimal Cluster Number
```{r kproto_combined}
# Combine results from the above methods
kproto_methods_df <- data.frame(
  K = 2:kproto_max_k,
  Silhouette = kproto_sil_width,
  WSS = kproto_wss,
  Gap = kproto_gap_stat$Tab[2:kproto_max_k,"gap"]
)

# Standardize metrics for comparison
kproto_methods_scaled <- kproto_methods_df %>%
  mutate(
    Silhouette_scaled = scale(Silhouette),
    WSS_scaled = -scale(WSS),  # Negative sign makes smaller WSS have higher standardized score
    Gap_scaled = scale(Gap)
  )

# Calculate average scores
kproto_methods_scaled <- kproto_methods_scaled %>%
  mutate(
    Average_score = (Silhouette_scaled + WSS_scaled + Gap_scaled) / 3
  )

# Plot combined scores
kproto_combined_plot <- ggplot(kproto_methods_scaled, 
                              aes(x = K, y = Average_score)) +
  geom_line() +
  geom_point() +
  geom_text(aes(label = round(Average_score, 2)), vjust = -1) +
  labs(title = "Combined Scores for Different Cluster Numbers",
       x = "Number of Clusters (k)",
       y = "Average Score (Standardized)") +
  theme_minimal()

print(kproto_combined_plot)

# Find the k value with the highest score
kproto_best_k_combined <- kproto_methods_scaled$K[
  which.max(kproto_methods_scaled$Average_score)
]
cat("Optimal number of clusters based on combined evaluation:", kproto_best_k_combined, "\n")

# Create a small table summarizing results from different methods
kproto_summary_table <- data.frame(
  Method = c("Silhouette Analysis", "Elbow Method", "Gap Statistic", 
             "Cluster Stability", "Combined Scores"),
  Suggested_K = c(
    kproto_best_k_sil,
    kproto_best_k_elbow,
    kproto_best_k_gap,
    kproto_best_k_stability,
    kproto_best_k_combined
  )
)

# Output summary table
print(kproto_summary_table)
```

## K-Prototypes Clustering Implementation
Based on the previous analysis, we select K=2 and K=3 for K-Prototypes clustering and compare the results.

```{r kprototypes_clustering}
# Set random seed for reproducibility
set.seed(123)

# Perform K-Prototypes clustering with k=2 and k=3
kproto_k2_result <- kproto(kproto_data_mixed, k = 2, verbose = FALSE)
kproto_k3_result <- kproto(kproto_data_mixed, k = 3, verbose = FALSE)

# Create comparison dataset with both clustering results
kproto_comparison_data <- kproto_data %>%
  mutate(
    kproto_cluster_k2 = factor(kproto_k2_result$cluster),
    kproto_cluster_k3 = factor(kproto_k3_result$cluster)
  )

# Add ID and PDM type for analysis
kproto_full_results <- cbind(
  ID = original_data$ID,
  PDM_Type = original_data$PDM_Type,
  kproto_comparison_data
)

# Save K-Prototypes clustering results
write.csv(kproto_full_results, "Results/BOAT2_KProto_Clustering_Results.csv", row.names = FALSE)

# Create visualizations for numerical variables
kproto_numerical_plots <- list()
for(var in numerical_org_vars) {
  # K=2 boxplot
  p1 <- ggplot(
    kproto_comparison_data, 
    aes_string(x = "kproto_cluster_k2", y = var, fill = "kproto_cluster_k2")
  ) +
    geom_boxplot() +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=2"), x = "Cluster", y = var) +
    theme_minimal() +
    theme(legend.position = "none")
  
  # K=3 boxplot
  p2 <- ggplot(
    kproto_comparison_data, 
    aes_string(x = "kproto_cluster_k3", y = var, fill = "kproto_cluster_k3")
  ) +
    geom_boxplot() +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=3"), x = "Cluster", y = var) +
    theme_minimal() +
    theme(legend.position = "none")
  
  kproto_numerical_plots[[var]] <- grid.arrange(p1, p2, ncol = 2)
}

# Create heatmap for ordinal variable cluster characteristics
kproto_characteristics <- bind_rows(
  # K=2 characteristics
  kproto_comparison_data %>%
    group_by(kproto_cluster_k2) %>%
    summarise(across(all_of(ordinal_all_vars), mean)) %>%
    pivot_longer(
      -kproto_cluster_k2, 
      names_to = "variable", 
      values_to = "value"
    ) %>%
    mutate(
      k = "K=2", 
      cluster = as.character(kproto_cluster_k2)
    ) %>%
    select(-kproto_cluster_k2),
  
  # K=3 characteristics
  kproto_comparison_data %>%
    group_by(kproto_cluster_k3) %>%
    summarise(across(all_of(ordinal_all_vars), mean)) %>%
    pivot_longer(
      -kproto_cluster_k3, 
      names_to = "variable", 
      values_to = "value"
    ) %>%
    mutate(
      k = "K=3", 
      cluster = as.character(kproto_cluster_k3)
    ) %>%
    select(-kproto_cluster_k3)
)

# Create heatmap
kproto_heatmap <- ggplot(
  kproto_characteristics, 
  aes(
    x = variable, 
    y = paste(k, "Cluster", cluster), 
    fill = value
  )
) +
  geom_tile() +
  scale_fill_viridis() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "K-Prototypes Cluster Characteristics Heatmap",
       x = "Variables",
       y = "Clusters")

# Save visualization results
pdf("Results/BOAT2_KProto_Analysis.pdf", width = 15, height = 15)

# Output numerical variable plots
for(plot in kproto_numerical_plots) {
  grid.arrange(plot)
}

# Output heatmap
print(kproto_heatmap)

# Output silhouette plots
par(mfrow = c(1,2))
plot(silhouette(kproto_k2_result$cluster, 
               daisy(kproto_data_mixed, metric = "gower")), 
     main = "K-Prototypes Silhouette Plot - K=2")
plot(silhouette(kproto_k3_result$cluster, 
               daisy(kproto_data_mixed, metric = "gower")), 
     main = "K-Prototypes Silhouette Plot - K=3")

dev.off()

# Analyze relationship between K-Prototypes clustering and PDM types
kproto_pdm_analysis <- data.frame(
  ID = original_data$ID,
  PDM_Type = original_data$PDM_Type,
  KProto_k2 = kproto_k2_result$cluster,
  KProto_k3 = kproto_k3_result$cluster
)

# Create contingency tables for PDM types and clusters
kproto_pdm_k2_table <- table(kproto_pdm_analysis$PDM_Type, kproto_pdm_analysis$KProto_k2)
kproto_pdm_k3_table <- table(kproto_pdm_analysis$PDM_Type, kproto_pdm_analysis$KProto_k3)

# Display contingency tables
cat("\nContingency table of K-Prototypes (k=2) and PDM types:\n")
print(kproto_pdm_k2_table)

cat("\nContingency table of K-Prototypes (k=3) and PDM types:\n")
print(kproto_pdm_k3_table)

# Calculate percentage of PDM types in each cluster
kproto_pdm_k2_percent <- prop.table(kproto_pdm_k2_table, margin = 2) * 100
kproto_pdm_k3_percent <- prop.table(kproto_pdm_k3_table, margin = 2) * 100

cat("\nPercentage of PDM types in each K-Prototypes (k=2) cluster:\n")
print(round(kproto_pdm_k2_percent, 1))

cat("\nPercentage of PDM types in each K-Prototypes (k=3) cluster:\n")
print(round(kproto_pdm_k3_percent, 1))
```

## Detailed Cluster Analysis and Visualization
This section provides detailed analysis of the clusters and creates various visualizations to understand the characteristics of each cluster.

```{r}
# Create dataset for kprototypes
kproto_data_mixed <- kproto_data
kproto_data_mixed[ordinal_all_vars] <- lapply(kproto_data_mixed[ordinal_all_vars], 
                                         function(x) ordered(round(x), levels = 1:5))

# Set random seed for reproducibility
set.seed(123)

# Perform clustering with k=2 and k=3
k2_result <- kproto(kproto_data_mixed, k = 2)
k3_result <- kproto(kproto_data_mixed, k = 3, verbose = FALSE)

# Create comparison dataset
comparison_data <- kproto_data %>%
  mutate(
    cluster_k2 = factor(k2_result$cluster),
    cluster_k3 = factor(k3_result$cluster)
  )

# Create visualizations for numerical variables
numerical_plots <- list()
for(var in numerical_org_vars) {
  # K=2 boxplot
  p1 <- ggplot(comparison_data, aes_string(x = "cluster_k2", y = var, fill = "cluster_k2")) +
    geom_boxplot() +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=2"), x = "Cluster", y = var) +
    theme_minimal()
  
  # K=3 boxplot
  p2 <- ggplot(comparison_data, aes_string(x = "cluster_k3", y = var, fill = "cluster_k3")) +
    geom_boxplot() +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=3"), x = "Cluster", y = var) +
    theme_minimal()
  
  numerical_plots[[var]] <- grid.arrange(p1, p2, ncol = 2)
}

# Create cluster characteristics heatmap
cluster_characteristics <- bind_rows(
  # K=2 characteristics
  comparison_data %>%
    group_by(cluster_k2) %>%
    summarise(across(all_of(ordinal_all_vars), mean)) %>%
    pivot_longer(-cluster_k2, names_to = "variable", values_to = "value") %>%
    mutate(k = "K=2", cluster = as.character(cluster_k2)) %>%
    select(-cluster_k2),
  
  # K=3 characteristics
  comparison_data %>%
    group_by(cluster_k3) %>%
    summarise(across(all_of(ordinal_all_vars), mean)) %>%
    pivot_longer(-cluster_k3, names_to = "variable", values_to = "value") %>%
    mutate(k = "K=3", cluster = as.character(cluster_k3)) %>%
    select(-cluster_k3)
)

# Create heatmap
characteristics_heatmap <- ggplot(cluster_characteristics, 
                                aes(x = variable, y = paste(k, "Cluster", cluster), 
                                    fill = value)) +
  geom_tile() +
  scale_fill_viridis() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Cluster Characteristics Heatmap",
       x = "Variables",
       y = "Clusters")

# Save visualizations
pdf("Cluster_Analysis_Visualizations.pdf", width = 15, height = 12)

# Print numerical variable plots
for(plot in numerical_plots) {
  grid.arrange(plot)
}

# Print heatmap
print(characteristics_heatmap)

# Print silhouette plots
par(mfrow = c(1,2))
plot(silhouette(k2_result$cluster, daisy(kproto_data_mixed, metric = "gower")), 
     main = "Silhouette Plot - K=2")
plot(silhouette(k3_result$cluster, daisy(kproto_data_mixed, metric = "gower")), 
     main = "Silhouette Plot - K=3")

dev.off()
```

## Dimension Reduction Analysis
This section performs PCA and UMAP analysis to visualize the clustering results in lower dimensions.

```{r dimensionality_reduction}
# Prepare data for dimensionality reduction
# Ensure consistent dataset sizes, check row counts of each dataset before merging
cat("Number of rows in merged_data:", nrow(merged_data), "\n")
cat("Number of rows in original_data:", nrow(original_data), "\n")
cat("Number of rows in kproto_data:", nrow(kproto_data), "\n")

# Use ID as key for merging to ensure all data rows align
# Select only variables needed for analysis
base_features <- merged_data %>%
  select(all_of(c(numerical_org_vars, merged_ordinal_vars)))

# Ensure the same observations are used before getting clustering results
# Get hierarchical clustering results, ensuring correct correspondence with IDs
hierarchical_results <- data.frame(
  ID = ids,  # IDs used in hierarchical clustering
  hier_cluster = factor(cutree(hc_ward, k = 3))
)

# Get K-Prototypes clustering results, ensuring correct correspondence with IDs
kproto_results <- data.frame(
  ID = original_data$ID,  # IDs used in K-Prototypes clustering
  kproto_k2 = factor(kproto_k2_result$cluster),
  kproto_k3 = factor(kproto_k3_result$cluster)
)

# PDM type data
pdm_data <- data.frame(
  ID = original_data$ID,
  PDM_Type = original_data$PDM_Type
)

# Merge all data using ID as key
# First merge features with hierarchical clustering results
dim_reduction_merged <- base_features %>%
  mutate(ID = merged_data$ID) %>%
  inner_join(hierarchical_results, by = "ID") %>%
  inner_join(kproto_results, by = "ID") %>%
  inner_join(pdm_data, by = "ID")

# Record number of rows after merging
cat("Number of rows after merging:", nrow(dim_reduction_merged), "\n")

# Extract feature data for dimensionality reduction (excluding clustering results and PDM)
dim_reduction_features <- dim_reduction_merged %>%
  select(-ID, -hier_cluster, -kproto_k2, -kproto_k3, -PDM_Type)

# PCA analysis
pca_result <- prcomp(dim_reduction_features, center = TRUE, scale. = TRUE)

# Extract principal component scores and add cluster labels and PDM information
pca_scores <- as.data.frame(pca_result$x)
pca_scores$ID <- dim_reduction_merged$ID
pca_scores$hier_cluster <- dim_reduction_merged$hier_cluster
pca_scores$kproto_k2 <- dim_reduction_merged$kproto_k2
pca_scores$kproto_k3 <- dim_reduction_merged$kproto_k3
pca_scores$PDM_Type <- dim_reduction_merged$PDM_Type

# UMAP dimensionality reduction
set.seed(123)
umap_config <- umap.defaults
umap_config$n_neighbors <- 15
umap_config$min_dist <- 0.1
umap_result <- umap(dim_reduction_features, config = umap_config)

# Extract UMAP results and add cluster labels and PDM information
umap_data <- as.data.frame(umap_result$layout)
names(umap_data) <- c("UMAP1", "UMAP2")
umap_data$ID <- dim_reduction_merged$ID
umap_data$hier_cluster <- dim_reduction_merged$hier_cluster
umap_data$kproto_k2 <- dim_reduction_merged$kproto_k2
umap_data$kproto_k3 <- dim_reduction_merged$kproto_k3
umap_data$PDM_Type <- dim_reduction_merged$PDM_Type

# Check dimensions of processed data
cat("Number of rows in PCA results:", nrow(pca_scores), "\n")
cat("Number of rows in UMAP results:", nrow(umap_data), "\n")

# Save dimensionality reduction results
write.csv(pca_scores, "Results/BOAT2_PCA_Results.csv", row.names = FALSE)
write.csv(umap_data, "Results/BOAT2_UMAP_Results.csv", row.names = FALSE)

# Create PCA visualizations
# Prepare PCA plotting function
plot_pca <- function(data, color_var, title_prefix, 
                    color_palette = "Set1", 
                    size = 3, 
                    alpha = 0.7) {
  p <- ggplot(data, aes(x = PC1, y = PC2, color = !!sym(color_var))) +
    geom_point(size = size, alpha = alpha) +
    labs(title = paste(title_prefix, "- PCA"),
         x = "PC1",
         y = "PC2") +
    theme_minimal()
  
  if (color_palette == "Set1") {
    p <- p + scale_color_brewer(palette = color_palette)
  } else if (color_palette == "viridis") {
    p <- p + scale_color_viridis_d()
  }
  
  return(p)
}

# Create PCA plots
pca_hier_plot <- plot_pca(pca_scores, "hier_cluster", 
                         "Hierarchical Clustering (k=3)")
pca_kproto_k2_plot <- plot_pca(pca_scores, "kproto_k2", 
                              "K-Prototypes (k=2)")
pca_kproto_k3_plot <- plot_pca(pca_scores, "kproto_k3", 
                              "K-Prototypes (k=3)")
pca_pdm_plot <- plot_pca(pca_scores, "PDM_Type", 
                        "Project Delivery Methods", 
                        color_palette = "Set2")

# Create UMAP visualizations
# Prepare UMAP plotting function
plot_umap <- function(data, color_var, title_prefix, 
                     color_palette = "Set1", 
                     size = 3, 
                     alpha = 0.7) {
  p <- ggplot(data, aes(x = UMAP1, y = UMAP2, color = !!sym(color_var))) +
    geom_point(size = size, alpha = alpha) +
    labs(title = paste(title_prefix, "- UMAP"),
         x = "UMAP1",
         y = "UMAP2") +
    theme_minimal()
  
  if (color_palette == "Set1") {
    p <- p + scale_color_brewer(palette = color_palette)
  } else if (color_palette == "viridis") {
    p <- p + scale_color_viridis_d()
  }
  
  return(p)
}

# Create UMAP plots
umap_hier_plot <- plot_umap(umap_data, "hier_cluster", 
                           "Hierarchical Clustering (k=3)")
umap_kproto_k2_plot <- plot_umap(umap_data, "kproto_k2", 
                                "K-Prototypes (k=2)")
umap_kproto_k3_plot <- plot_umap(umap_data, "kproto_k3", 
                                "K-Prototypes (k=3)")
umap_pdm_plot <- plot_umap(umap_data, "PDM_Type", 
                          "Project Delivery Methods", 
                          color_palette = "Set2")

# Save visualizations
pdf("Results/BOAT2_Dimensionality_Reduction_Plots.pdf", width = 14, height = 12)

# PCA plots
grid.arrange(pca_hier_plot, pca_kproto_k2_plot, 
             pca_kproto_k3_plot, pca_pdm_plot, 
             ncol = 2)

# UMAP plots
grid.arrange(umap_hier_plot, umap_kproto_k2_plot, 
             umap_kproto_k3_plot, umap_pdm_plot, 
             ncol = 2)

dev.off()

# Calculate PCA variance explained
pca_var <- pca_result$sdev^2
pca_var_pct <- pca_var / sum(pca_var) * 100
pca_var_cum <- cumsum(pca_var_pct)

# Create PCA variance explained plot
pca_var_df <- data.frame(
  Component = 1:length(pca_var_pct),
  Variance_Explained = pca_var_pct,
  Cumulative_Variance = pca_var_cum
)

# Plot PCA variance explained
pca_var_plot <- ggplot(pca_var_df, aes(x = Component)) +
  geom_col(aes(y = Variance_Explained), fill = "steelblue") +
  geom_line(aes(y = Cumulative_Variance), color = "red", size = 1) +
  geom_point(aes(y = Cumulative_Variance), color = "red", size = 3) +
  scale_y_continuous(
    name = "Variance Explained (%)",
    sec.axis = sec_axis(~., name = "Cumulative Variance (%)")
  ) +
  labs(title = "PCA Variance Explained",
       x = "Principal Component") +
  theme_minimal()

# Save PCA variance plot
pdf("Results/BOAT2_PCA_Variance_Explained.pdf", width = 10, height = 6)
print(pca_var_plot)
dev.off()

# Print variance explained by first few components
cat("Variance explained by PC1:", round(pca_var_pct[1], 2), "%\n")
cat("Variance explained by PC2:", round(pca_var_pct[2], 2), "%\n")
cat("Cumulative variance explained by PC1-PC2:", round(pca_var_cum[2], 2), "%\n")
cat("Cumulative variance explained by PC1-PC5:", round(pca_var_cum[5], 2), "%\n")
```

# 比较不同聚类方法

本部分比较不同聚类方法在业主决策特征分析中的表现。

```{r clustering_comparison}
# 不同聚类方法的比较

# 创建聚类方法比较表格
clustering_methods_comparison <- data.frame(
  Method = c("层次聚类 (Ward方法)", "K-Prototypes聚类"),
  Data_Types = c("仅数值数据", "混合类型数据 (数值 + 有序)"),
  Advantages = c(
    "适合发现层次结构; 不需要预先指定聚类数; 提供聚类间关系的树状图。",
    "能处理混合数据类型; 适用于不同缩放的变量; 计算效率较高，适合较大数据集。"
  ),
  Disadvantages = c(
    "对异常值敏感; 不适合处理非数值数据; 对大型数据集计算效率低。",
    "需要预先指定聚类数; 可能受初始聚类中心影响; 对参数设置较敏感。"
  ),
  Best_For = c(
    "探索性分析; 当聚类层次关系重要时; 聚类数不明确的情况。",
    "处理混合类型数据; 需要考虑类别变量和对比分析; 适合规模较大的实际应用场景。"
  )
)

# 展示比较表格
kable(clustering_methods_comparison, 
      caption = "不同聚类方法比较",
      align = c("l", "l", "l", "l", "l"))

# 计算不同聚类方法间的一致性
# 使用调整兰德指数 (Adjusted Rand Index)
# 将层次聚类结果转换为与kproto兼容的格式
hierarchical_clusters <- cutree(hc_ward, k = 3)

# 提取K-Prototypes聚类结果
kproto_clusters_k2 <- kproto_k2_result$cluster
kproto_clusters_k3 <- kproto_k3_result$cluster

# 确保数据对齐
# 获取所有可用的ID
common_ids <- intersect(
  intersect(
    names(hierarchical_clusters),
    names(kproto_clusters_k2)
  ),
  names(kproto_clusters_k3)
)

# 对齐聚类结果
hierarchical_clusters_aligned <- hierarchical_clusters[common_ids]
kproto_clusters_k2_aligned <- kproto_clusters_k2[common_ids]
kproto_clusters_k3_aligned <- kproto_clusters_k3[common_ids]

# 计算调整兰德指数
hc_kproto_k2_ari <- adjustedRandIndex(hierarchical_clusters_aligned, kproto_clusters_k2_aligned)
hc_kproto_k3_ari <- adjustedRandIndex(hierarchical_clusters_aligned, kproto_clusters_k3_aligned)
k2_k3_ari <- adjustedRandIndex(kproto_clusters_k2_aligned, kproto_clusters_k3_aligned)

# 创建一致性矩阵
consistency_matrix <- matrix(
  c(1, hc_kproto_k2_ari, hc_kproto_k3_ari,
    hc_kproto_k2_ari, 1, k2_k3_ari,
    hc_kproto_k3_ari, k2_k3_ari, 1),
  nrow = 3, 
  ncol = 3,
  dimnames = list(
    c("层次聚类 (k=3)", "K-Prototypes (k=2)", "K-Prototypes (k=3)"),
    c("层次聚类 (k=3)", "K-Prototypes (k=2)", "K-Prototypes (k=3)")
  )
)

# 可视化聚类一致性矩阵
heatmap_data <- as.data.frame(as.table(consistency_matrix))
names(heatmap_data) <- c("Method1", "Method2", "ARI")

# 创建热图
consistency_heatmap <- ggplot(heatmap_data, aes(x = Method1, y = Method2, fill = ARI)) +
  geom_tile() +
  geom_text(aes(label = round(ARI, 2)), color = "white", size = 4) +
  scale_fill_gradient(low = "blue", high = "red") +
  labs(title = "聚类方法一致性 (调整兰德指数)",
       x = "", y = "", fill = "调整兰德指数") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# 输出一致性结果
cat("\n不同聚类方法的一致性 (调整兰德指数):\n")
print(consistency_matrix)

# 保存结果
pdf("Results/BOAT2_Clustering_Method_Comparison.pdf", width = 10, height = 6)
print(consistency_heatmap)
dev.off()

# 创建聚类方法与PDM类型关系的比较图

# 准备数据 - 使用对齐后的ID
pdm_comparison_data <- data.frame(
  ID = common_ids,
  PDM_Type = original_data$PDM_Type[match(common_ids, original_data$ID)],
  HC_Cluster = factor(hierarchical_clusters_aligned),
  KProto_k2 = factor(kproto_clusters_k2_aligned),
  KProto_k3 = factor(kproto_clusters_k3_aligned)
)

# 创建函数以生成每种聚类方法的PDM分布图
create_pdm_distribution <- function(data, cluster_var, title) {
  ggplot(data, aes_string(x = cluster_var, fill = "PDM_Type")) +
    geom_bar(position = "fill") +
    scale_y_continuous(labels = scales::percent) +
    labs(title = title,
         x = "聚类",
         y = "比例") +
    theme_minimal() +
    scale_fill_brewer(palette = "Set1", name = "项目交付方法")
}

# 创建图表
pdm_hc_plot <- create_pdm_distribution(pdm_comparison_data, "HC_Cluster", 
                                     "层次聚类中PDM类型的分布 (k=3)")
pdm_kproto_k2_plot <- create_pdm_distribution(pdm_comparison_data, "KProto_k2", 
                                           "K-Prototypes聚类中PDM类型的分布 (k=2)")
pdm_kproto_k3_plot <- create_pdm_distribution(pdm_comparison_data, "KProto_k3", 
                                           "K-Prototypes聚类中PDM类型的分布 (k=3)")

# 保存PDM分布比较图
pdf("Results/BOAT2_Clustering_PDM_Relationship_Comparison.pdf", width = 12, height = 8)
grid.arrange(pdm_hc_plot, pdm_kproto_k2_plot, pdm_kproto_k3_plot, nrow = 2)
dev.off()

# 保存数据
write.csv(pdm_comparison_data, "Results/BOAT2_Clustering_PDM_Comparison_Data.csv", row.names = FALSE)
```

# 结论与讨论

# 总结聚类分析结果
cat("\n## 聚类分析结果总结\n")
cat("\n### 最佳聚类数量\n")
cat("- 层次聚类：通过肘部法则和间隙统计确定最优聚类数为3。\n")
cat("- K-Prototypes：通过轮廓分析、肘部法则、间隙统计和稳定性分析确定最优聚类数为2-3，两者均有其解释价值。\n")

cat("\n### 层次聚类特征\n")
cat("- 聚类1：较小规模组织，偏好传统的业主控制模式，注重成本控制。\n")
cat("- 聚类2：中等规模组织，偏好综合项目管理，注重进度和质量。\n")
cat("- 聚类3：大型组织，更倾向于创新交付方法，关注全生命周期价值。\n")

cat("\n### K-Prototypes聚类特征\n")
cat("- K=2时：\n")
cat("  - 聚类1：传统导向型业主，偏好业主控制，注重成本因素。\n")
cat("  - 聚类2：创新导向型业主，更愿意采用新型项目交付方法，注重整体价值。\n")
cat("- K=3时：\n")
cat("  - 聚类1：小型传统业主，更注重直接控制和成本管理。\n")
cat("  - 聚类2：中型混合业主，平衡成本与其他因素。\n")
cat("  - 聚类3：大型创新业主，更关注整体价值和长期效益。\n")

cat("\n### 聚类与PDM类型的关系\n")
cat("- 层次聚类：聚类3与IPD、DB关联度较高；聚类1与DBB关联性更强。\n")
cat("- K-Prototypes (k=2)：\n")
cat("  - 聚类1与传统交付方法（尤其是DBB）关联性更高。\n")
cat("  - 聚类2与创新交付方法（如IPD、DB）关联性更高。\n")
cat("- K-Prototypes (k=3)：\n")
cat("  - 聚类1主要与DBB关联。\n")
cat("  - 聚类2表现为混合PDM分布，各类型相对均衡。\n")
cat("  - 聚类3与IPD、DB等创新方法关联性明显更高。\n")

# 讨论
cat("\n## 讨论与实践意义\n")

cat("\n### 实践启示\n")
cat("1. **差异化业主管理策略**：项目参与方应根据业主的聚类特征，制定差异化的沟通和协作策略。\n")
cat("2. **PDM选择指导**：研究结果可指导业主根据自身特征选择更适合的项目交付方法。\n")
cat("3. **创新方法的推广**：对于创新导向型业主，可更积极地推广IPD等创新交付方法。\n")
cat("4. **混合方法的应用**：对于特征混合的业主，可考虑结合多种交付方法的优势。\n")

cat("\n### 方法论贡献\n")
cat("1. **混合数据聚类**：成功应用K-Prototypes聚类处理混合数据类型，为建筑管理研究提供了新的分析范式。\n")
cat("2. **多方法验证**：通过层次聚类与K-Prototypes的比较，提高了分析结果的可靠性。\n")
cat("3. **聚类稳定性分析**：引入了聚类稳定性分析方法，增强了结果的可靠性和解释力。\n")

cat("\n### 研究局限\n")
cat("1. **样本规模**：样本数量有限，可能影响聚类结果的稳定性和代表性。\n")
cat("2. **地域限制**：研究主要基于特定地区数据，结果可能不完全适用于其他地区或文化背景。\n")
cat("3. **静态分析**：本研究为截面分析，未能捕捉业主决策特征的动态变化。\n")

cat("\n### 未来研究方向\n")
cat("1. **纵向研究**：开展纵向研究，分析业主决策特征随时间的变化。\n")
cat("2. **拓展样本**：扩大样本规模和地域覆盖，提高结果代表性。\n")
cat("3. **深入机制研究**：探究聚类特征形成的深层次机制与影响因素。\n")
cat("4. **基于聚类的预测模型**：开发基于聚类的业主决策预测模型，为项目管理实践提供更精准的决策支持。\n")


```{r}
# 创建K-Prototypes聚类结果的可视化
# 准备数据
kproto_viz_data <- kproto_data %>%
  mutate(
    kproto_cluster_k2 = factor(kproto_k2_result$cluster),
    kproto_cluster_k3 = factor(kproto_k3_result$cluster)
  )

# 创建箱线图函数
create_boxplot <- function(data, var, cluster_var, title) {
  ggplot(data, aes_string(x = cluster_var, y = var, fill = cluster_var)) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = title,
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 45, hjust = 1),
          plot.title = element_text(size = 8))
}

# 创建K=2的变量分布图
k2_plots <- list()
# 组织结构变量
for(var in numerical_org_vars) {
  k2_plots[[var]] <- create_boxplot(kproto_viz_data, var, "kproto_cluster_k2", 
                                   paste(var, "- K=2"))
}
# 有序变量
for(var in ordinal_all_vars) {
  k2_plots[[var]] <- create_boxplot(kproto_viz_data, var, "kproto_cluster_k2", 
                                   paste(var, "- K=2"))
}

# 创建K=3的变量分布图
k3_plots <- list()
# 组织结构变量
for(var in numerical_org_vars) {
  k3_plots[[var]] <- create_boxplot(kproto_viz_data, var, "kproto_cluster_k3", 
                                   paste(var, "- K=3"))
}
# 有序变量
for(var in ordinal_all_vars) {
  k3_plots[[var]] <- create_boxplot(kproto_viz_data, var, "kproto_cluster_k3", 
                                   paste(var, "- K=3"))
}

# 保存K=2的变量分布图
pdf("Results/BOAT2_KProto_k2_Variable_Distribution.pdf", width = 15, height = 20)
grid.arrange(grobs = k2_plots, ncol = 3)
dev.off()

# 保存K=3的变量分布图
pdf("Results/BOAT2_KProto_k3_Variable_Distribution.pdf", width = 15, height = 20)
grid.arrange(grobs = k3_plots, ncol = 3)
dev.off()

# 创建聚类特征热图
# 准备热图数据
k2_characteristics <- kproto_viz_data %>%
  group_by(kproto_cluster_k2) %>%
  summarise(across(everything(), mean)) %>%
  pivot_longer(-kproto_cluster_k2, 
               names_to = "variable", 
               values_to = "value")

k3_characteristics <- kproto_viz_data %>%
  group_by(kproto_cluster_k3) %>%
  summarise(across(everything(), mean)) %>%
  pivot_longer(-kproto_cluster_k3, 
               names_to = "variable", 
               values_to = "value")

# 创建热图函数
create_heatmap <- function(data, cluster_var, title) {
  ggplot(data, aes_string(x = "variable", y = cluster_var, fill = "value")) +
    geom_tile() +
    scale_fill_viridis() +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = title,
         x = "变量",
         y = "聚类")
}

# 创建并保存热图
k2_heatmap <- create_heatmap(k2_characteristics, "kproto_cluster_k2", 
                            "K-Prototypes聚类特征热图 (k=2)")
k3_heatmap <- create_heatmap(k3_characteristics, "kproto_cluster_k3", 
                            "K-Prototypes聚类特征热图 (k=3)")

# 保存热图
pdf("Results/BOAT2_KProto_Cluster_Characteristics_Heatmap.pdf", width = 15, height = 8)
grid.arrange(k2_heatmap, k3_heatmap, ncol = 2)
dev.off()

# 输出聚类统计信息
cat("\nK-Prototypes聚类统计信息：\n")
cat("\nK=2聚类大小：\n")
print(table(kproto_viz_data$kproto_cluster_k2))
cat("\nK=3聚类大小：\n")
print(table(kproto_viz_data$kproto_cluster_k3))

# 保存聚类结果
write.csv(kproto_viz_data, "Results/BOAT2_KProto_Clustering_Results.csv", row.names = FALSE)
```

# K-2和K-3聚类结果对比可视化

```{r k2_k3_comparison}
# 准备对比数据
comparison_data <- kproto_data %>%
  mutate(
    kproto_cluster_k2 = factor(kproto_k2_result$cluster),
    kproto_cluster_k3 = factor(kproto_k3_result$cluster)
  )

# 创建对比可视化函数
create_comparison_plot <- function(data, var, title) {
  # K=2箱线图
  p1 <- ggplot(data, aes_string(x = "kproto_cluster_k2", y = var, fill = "kproto_cluster_k2")) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = paste(title, "- K=2"),
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 10))
  
  # K=3箱线图
  p2 <- ggplot(data, aes_string(x = "kproto_cluster_k3", y = var, fill = "kproto_cluster_k3")) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = paste(title, "- K=3"),
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 10))
  
  # 组合两个图
  grid.arrange(p1, p2, ncol = 2)
}

# 创建组织结构变量的对比图
org_plots <- list()
for(var in numerical_org_vars) {
  org_plots[[var]] <- create_comparison_plot(comparison_data, var, var)
}

# 创建有序变量的对比图
ordinal_plots <- list()
for(var in ordinal_all_vars) {
  ordinal_plots[[var]] <- create_comparison_plot(comparison_data, var, var)
}

# 保存组织结构变量的对比图（分页）
pdf("Results/BOAT2_K2_K3_Organizational_Structure_Comparison.pdf", width = 20, height = 10)
for(plot in org_plots) {
  grid.arrange(plot)
}
dev.off()

# 创建组织结构变量的组合对比图（单页）
# 计算需要的行数和列数
n_vars <- length(numerical_org_vars)
n_cols <- 2  # 每行显示两个变量
n_rows <- ceiling(n_vars / n_cols)

# 创建组合图
pdf("Results/BOAT2_K2_K3_Organizational_Structure_Combination_Comparison.pdf", width = 20, height = 10 * n_rows)

# 创建标题
title_grob <- textGrob("K-2和K-3聚类组织结构特征对比", 
                       gp = gpar(fontsize = 16, fontface = "bold"))

# 创建所有箱线图
plot_list <- list()
for(var in numerical_org_vars) {
  # K=2箱线图
  p1 <- ggplot(comparison_data, aes_string(x = "kproto_cluster_k2", y = var, fill = "kproto_cluster_k2")) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=2"),
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 10))
  
  # K=3箱线图
  p2 <- ggplot(comparison_data, aes_string(x = "kproto_cluster_k3", y = var, fill = "kproto_cluster_k3")) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=3"),
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 10))
  
  # 组合两个图
  plot_list[[var]] <- grid.arrange(p1, p2, ncol = 2)
}

# 创建网格布局
grid.arrange(
  title_grob,
  do.call(grid.arrange, c(plot_list, ncol = n_cols)),
  nrow = 2,
  heights = c(0.1, 0.9)
)

dev.off()

# 创建组织结构变量的组合对比图（改进版）
pdf("Results/BOAT2_K2_K3_Organizational_Structure_Combination_Comparison_Improved.pdf", width = 20, height = 10 * n_rows)

# 创建主标题
main_title <- textGrob("K-2和K-3聚类组织结构特征对比", 
                       gp = gpar(fontsize = 16, fontface = "bold"))

# 创建子标题
subtitle <- textGrob("组织结构特征在不同聚类数量下的分布对比", 
                     gp = gpar(fontsize = 12))

# 创建所有箱线图
plot_list <- list()
for(var in numerical_org_vars) {
  # K=2箱线图
  p1 <- ggplot(comparison_data, aes_string(x = "kproto_cluster_k2", y = var, fill = "kproto_cluster_k2")) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=2"),
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 10),
          plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))
  
  # K=3箱线图
  p2 <- ggplot(comparison_data, aes_string(x = "kproto_cluster_k3", y = var, fill = "kproto_cluster_k3")) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=3"),
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 10),
          plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))
  
  # 组合两个图
  plot_list[[var]] <- grid.arrange(p1, p2, ncol = 2, widths = c(1, 1))
}

# 创建网格布局
grid.arrange(
  main_title,
  subtitle,
  do.call(grid.arrange, c(plot_list, ncol = 2)),
  nrow = 3,
  heights = c(0.05, 0.05, 0.9)
)

dev.off()

# 创建组织结构变量的组合对比图（最终版）
# 首先创建所有单独的图形对象
plot_list <- list()

for(var in numerical_org_vars) {
  # K=2箱线图
  p1 <- ggplot(comparison_data, aes_string(x = "kproto_cluster_k2", y = var)) +
    geom_boxplot(aes(fill = kproto_cluster_k2), alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=2"),
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 14),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))
  
  # K=3箱线图
  p2 <- ggplot(comparison_data, aes_string(x = "kproto_cluster_k3", y = var)) +
    geom_boxplot(aes(fill = kproto_cluster_k3), alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = paste(var, "- K=3"),
         x = "聚类",
         y = var) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 14),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))
  
  # 将两个图存储为一个列表
  plot_list[[var]] <- list(p1, p2)
}

# 创建主标题
title_plot <- ggplot() + 
  annotate("text", x = 0.5, y = 0.8, 
           label = "K-2和K-3聚类组织结构特征对比",
           size = 8, fontface = "bold") +
  annotate("text", x = 0.5, y = 0.2,
           label = "组织结构特征在不同聚类数量下的分布对比",
           size = 6) +
  theme_void()

# 使用png设备创建高分辨率图像
png("Results/BOAT2_K2_K3_Organizational_Structure_Combination_Final_Version.png", 
    width = 2400, height = 1800, res = 300)

# 设置图形布局
grid.newpage()
pushViewport(viewport(layout = grid.layout(3, 4)))  # 3行4列的布局

# 绘制标题（跨越所有列）
print(title_plot, vp = viewport(layout.pos.row = 1, layout.pos.col = 1:4))

# 绘制箱线图
row_counter <- 2
col_counter <- 1
for(var in numerical_org_vars) {
  if(col_counter > 2) {
    row_counter <- row_counter + 1
    col_counter <- 1
  }
  
  # 计算当前变量的视口位置
  current_col_start <- (col_counter - 1) * 2 + 1
  current_col_end <- current_col_start + 1
  
  # 创建组合图
  combined_plot <- grid.arrange(
    plot_list[[var]][[1]], 
    plot_list[[var]][[2]], 
    ncol = 2,
    widths = c(1, 1)
  )
  
  # 打印组合图
  print(combined_plot, 
        vp = viewport(layout.pos.row = row_counter,
                     layout.pos.col = current_col_start:current_col_end))
  
  col_counter <- col_counter + 1
}

dev.off()

# 保存聚类统计信息
cat("\nK-Prototypes聚类统计信息：\n")
cat("\nK=2聚类大小：\n")
print(table(comparison_data$kproto_cluster_k2))
cat("\nK=3聚类大小：\n")
print(table(comparison_data$kproto_cluster_k3))

# 计算调整兰德指数
ari <- adjustedRandIndex(
  as.numeric(as.character(comparison_data$kproto_cluster_k2)),
  as.numeric(as.character(comparison_data$kproto_cluster_k3))
)
cat("\nK-2和K-3聚类的调整兰德指数:", round(ari, 3), "\n")
```

# Radar Plot Visualization Analysis

```{r radar_plot_analysis}
# Load required packages
library(fmsb)  # For creating radar charts
library(tidyr) # For data reshaping
library(dplyr) # For data processing

# Prepare radar plot data
# First merge paired variables
radar_data <- kproto_data %>%
  mutate(
    # Merge paired variables
    Distribution_Centralization = (Distribution_Centralization1 + Distribution_Centralization2) / 2,
    Distribution_Formalization = (Distribution_Formalization1 + Distribution_Formalization2) / 2,
    Style_Participation = (Style_Participation1 + Style_Participation2) / 2,
    Style_Organicity = (Style_Organicity1 + Style_Organicity2) / 2,
    Style_Coercion = (Style_Coercion1 + Style_Coercion2) / 2
  ) %>%
  # Select variables for radar plot
  select(
    # Merged variables
    Distribution_Centralization,
    Distribution_Formalization,
    Style_Participation,
    Style_Organicity,
    Style_Coercion,
    # Other ordinal variables
    Style_Technocracy,
    Culture_Command,
    Culture_Symbolic,
    Culture_Rationale,
    Culture_Generative,
    Culture_Transactive,
    Flexibility_openness,
    Flexibility_Recursiveness,
    Risk,
    Environment_Growth,
    Environment_Hostile,
    Environment_Stable
  )

# Calculate mean values for each cluster
radar_k2 <- radar_data %>%
  mutate(cluster = factor(kproto_k2_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean))

radar_k3 <- radar_data %>%
  mutate(cluster = factor(kproto_k3_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean))

# Prepare radar plot data format
# Add max and min rows (required for radar plot)
radar_k2_plot <- rbind(
  rep(5, ncol(radar_k2) - 1),  # Maximum
  rep(0, ncol(radar_k2) - 1),  # Minimum
  radar_k2 %>% select(-cluster)  # Actual data
)

radar_k3_plot <- rbind(
  rep(5, ncol(radar_k3) - 1),  # Maximum
  rep(0, ncol(radar_k3) - 1),  # Minimum
  radar_k3 %>% select(-cluster)  # Actual data
)

# Set variable names (using more readable labels)
colnames(radar_k2_plot) <- c(
  "Centralization", "Formalization", "Participation", "Organicity", "Coercion",
  "Technocracy", "Command Culture", "Symbolic Culture", "Rationale Culture", 
  "Generative Culture", "Transactive Culture", "Openness", "Recursiveness", 
  "Risk", "Growth Environment", "Hostile Environment", "Stable Environment"
)

colnames(radar_k3_plot) <- colnames(radar_k2_plot)

# Create radar plot function
create_radar_plot <- function(data, title, colors) {
  # Create the radar chart with basic settings
  radarchart(data,
             axistype = 1,
             pcol = colors,
             pfcol = alpha(colors, 0.3),
             plwd = 2,
             plty = 1,
             cglcol = "grey",
             cglty = 1,
             axislabcol = "grey",
             caxislabels = seq(0, 5, 1),
             cglwd = 0.8,
             vlcex = 0.8,  # Increase label size
             title = title)
}

# Create output directory if it doesn't exist
dir.create("Results", showWarnings = FALSE)

# Create radar plots
pdf("Results/BOAT2_Radar_Plot_Analysis.pdf", width = 15, height = 10)

# K=2 radar plot
par(mfrow = c(1, 2))
create_radar_plot(radar_k2_plot, "K-Prototypes Clustering Radar Plot (k=2)", colors_k2)
legend("topright", 
       legend = paste("Cluster", 1:2),
       col = colors_k2,
       lwd = 2,
       bty = "n")

# K=3 radar plot
create_radar_plot(radar_k3_plot, "K-Prototypes Clustering Radar Plot (k=3)", colors_k3)
legend("topright", 
       legend = paste("Cluster", 1:3),
       col = colors_k3,
       lwd = 2,
       bty = "n")

dev.off()

# Create individual radar plots (one for each cluster)
pdf("Results/BOAT2_Cluster_Radar_Plots_Individual.pdf", width = 20, height = 12)

# K=2 individual radar plots
par(mfrow = c(1, 2))
for(i in 1:2) {
  cluster_data <- rbind(
    rep(5, ncol(radar_k2) - 1),
    rep(0, ncol(radar_k2) - 1),
    radar_k2 %>% filter(cluster == i) %>% select(-cluster)
  )
  colnames(cluster_data) <- colnames(radar_k2_plot)
  create_radar_plot(cluster_data, 
                   paste("Cluster", i, "Characteristics Radar Plot (k=2)"),
                   colors_k2[i])
}

# K=3 individual radar plots
par(mfrow = c(1, 3))
for(i in 1:3) {
  cluster_data <- rbind(
    rep(5, ncol(radar_k3) - 1),
    rep(0, ncol(radar_k3) - 1),
    radar_k3 %>% filter(cluster == i) %>% select(-cluster)
  )
  colnames(cluster_data) <- colnames(radar_k3_plot)
  create_radar_plot(cluster_data, 
                   paste("Cluster", i, "Characteristics Radar Plot (k=3)"),
                   colors_k3[i])
}

dev.off()

# Save radar plot data
write.csv(radar_k2, "Results/BOAT2_Radar_Plot_Data_k2.csv", row.names = FALSE)
write.csv(radar_k3, "Results/BOAT2_Radar_Plot_Data_k3.csv", row.names = FALSE)
```



# Organizational Structure Radar Plot Analysis

```{r org_structure_radar}
# Prepare data for organizational structure radar plots
org_structure_data <- kproto_data %>%
  select(
    Org_Structure_Employees,
    Org_Structure_Locations,
    Org_Structure_Depts,
    Org_Structure_Layers
  )

# Scale the organizational structure variables to 0-5 range for consistency
org_structure_scaled <- org_structure_data %>%
  mutate(across(everything(), function(x) {
    5 * (x - min(x)) / (max(x) - min(x))
  }))

# Calculate means for each cluster (K=2)
org_radar_k2 <- org_structure_scaled %>%
  mutate(cluster = factor(kproto_k2_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean))

# Calculate means for each cluster (K=3)
org_radar_k3 <- org_structure_scaled %>%
  mutate(cluster = factor(kproto_k3_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean))

# Prepare radar plot data format (K=2)
org_radar_k2_plot <- rbind(
  rep(5, ncol(org_structure_scaled)),  # Maximum
  rep(0, ncol(org_structure_scaled)),  # Minimum
  org_radar_k2 %>% select(-cluster)    # Actual data
)

# Prepare radar plot data format (K=3)
org_radar_k3_plot <- rbind(
  rep(5, ncol(org_structure_scaled)),  # Maximum
  rep(0, ncol(org_structure_scaled)),  # Minimum
  org_radar_k3 %>% select(-cluster)    # Actual data
)

# Set more readable variable names
colnames(org_radar_k2_plot) <- c(
  "Employees",
  "Locations",
  "Departments",
  "Hierarchical Layers"
)
colnames(org_radar_k3_plot) <- colnames(org_radar_k2_plot)

# Create output directory if it doesn't exist
dir.create("Results", showWarnings = FALSE)

# Create radar plots for organizational structure
pdf("Results/BOAT2_Org_Structure_Radar_Analysis.pdf", width = 15, height = 10)

# K=2 radar plot
par(mfrow = c(1, 2))
create_radar_plot(org_radar_k2_plot, 
                 "Organizational Structure Characteristics (k=2)", 
                 colors_k2)
legend("topright", 
       legend = paste("Cluster", 1:2),
       col = colors_k2,
       lwd = 2,
       bty = "n")

# K=3 radar plot
create_radar_plot(org_radar_k3_plot, 
                 "Organizational Structure Characteristics (k=3)", 
                 colors_k3)
legend("topright", 
       legend = paste("Cluster", 1:3),
       col = colors_k3,
       lwd = 2,
       bty = "n")

dev.off()

# Create individual radar plots for each cluster
pdf("Results/BOAT2_Org_Structure_Cluster_Radar_Individual.pdf", width = 20, height = 12)

# K=2 individual radar plots
par(mfrow = c(1, 2))
for(i in 1:2) {
  cluster_data <- rbind(
    rep(5, ncol(org_structure_scaled)),
    rep(0, ncol(org_structure_scaled)),
    org_radar_k2 %>% filter(cluster == i) %>% select(-cluster)
  )
  colnames(cluster_data) <- colnames(org_radar_k2_plot)
  create_radar_plot(cluster_data, 
                   paste("Cluster", i, "Organizational Structure (k=2)"),
                   colors_k2[i])
}

# K=3 individual radar plots
par(mfrow = c(1, 3))
for(i in 1:3) {
  cluster_data <- rbind(
    rep(5, ncol(org_structure_scaled)),
    rep(0, ncol(org_structure_scaled)),
    org_radar_k3 %>% filter(cluster == i) %>% select(-cluster)
  )
  colnames(cluster_data) <- colnames(org_radar_k3_plot)
  create_radar_plot(cluster_data, 
                   paste("Cluster", i, "Organizational Structure (k=3)"),
                   colors_k3[i])
}

dev.off()

# Save organizational structure radar plot data
write.csv(org_radar_k2, "Results/BOAT2_Org_Structure_Radar_Data_k2.csv", row.names = FALSE)
write.csv(org_radar_k3, "Results/BOAT2_Org_Structure_Radar_Data_k3.csv", row.names = FALSE)
```

# Organizational Structure Radar Plot with Original Scales

```{r org_structure_radar_original}
# Prepare data for organizational structure radar plots
org_structure_data <- kproto_data %>%
  select(
    Org_Structure_Employees,
    Org_Structure_Locations,
    Org_Structure_Depts,
    Org_Structure_Layers
  )

# Calculate means for each cluster (K=2)
org_radar_k2 <- org_structure_data %>%
  mutate(cluster = factor(kproto_k2_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean))

# Calculate means for each cluster (K=3)
org_radar_k3 <- org_structure_data %>%
  mutate(cluster = factor(kproto_k3_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean))

# Calculate max values for each variable to set scales
max_values <- sapply(org_structure_data, max)
min_values <- sapply(org_structure_data, min)

# Round max values up to nice numbers for plotting
nice_max <- function(x) {
  magnitude <- 10^floor(log10(x))
  ceiling(x/magnitude) * magnitude
}
max_scales <- sapply(max_values, nice_max)

# Prepare radar plot data format (K=2)
org_radar_k2_plot <- rbind(
  max_scales,                           # Maximum values
  rep(0, ncol(org_structure_data)),    # Minimum values
  org_radar_k2 %>% select(-cluster)    # Actual data
)

# Prepare radar plot data format (K=3)
org_radar_k3_plot <- rbind(
  max_scales,                           # Maximum values
  rep(0, ncol(org_structure_data)),    # Minimum values
  org_radar_k3 %>% select(-cluster)    # Actual data
)

# Set more readable variable names with scales
colnames(org_radar_k2_plot) <- c(
  paste0("Employees\n(0-", max_scales[1], ")"),
  paste0("Locations\n(0-", max_scales[2], ")"),
  paste0("Departments\n(0-", max_scales[3], ")"),
  paste0("Hierarchical Layers\n(0-", max_scales[4], ")")
)
colnames(org_radar_k3_plot) <- colnames(org_radar_k2_plot)

# Create modified radar plot function with custom scales
create_radar_plot_custom <- function(data, title, colors) {
  radarchart(data,
             axistype = 1,
             pcol = colors,
             pfcol = alpha(colors, 0.3),
             plwd = 2,
             plty = 1,
             cglcol = "grey",
             cglty = 1,
             axislabcol = "grey",
             caxislabels = sapply(1:ncol(data), function(i) {
               seq(0, data[1,i], length.out = 6)
             }),
             cglwd = 0.8,
             vlcex = 0.8,
             title = title)
}

# Create output directory if it doesn't exist
dir.create("Results", showWarnings = FALSE)

# Create radar plots for organizational structure
pdf("Results/BOAT2_Org_Structure_Radar_Original_Scales.pdf", width = 15, height = 10)

# Display data ranges
cat("Data Ranges for Each Variable:\n")
for(i in 1:ncol(org_structure_data)) {
  cat(sprintf("%s: %.0f - %.0f\n", 
              names(org_structure_data)[i], 
              min_values[i], 
              max_values[i]))
}

# K=2 radar plot
par(mfrow = c(1, 2))
create_radar_plot_custom(org_radar_k2_plot, 
                        "Organizational Structure Characteristics (k=2)\nOriginal Scales", 
                        colors_k2)
legend("topright", 
       legend = paste("Cluster", 1:2),
       col = colors_k2,
       lwd = 2,
       bty = "n")

# K=3 radar plot
create_radar_plot_custom(org_radar_k3_plot, 
                        "Organizational Structure Characteristics (k=3)\nOriginal Scales", 
                        colors_k3)
legend("topright", 
       legend = paste("Cluster", 1:3),
       col = colors_k3,
       lwd = 2,
       bty = "n")

dev.off()

# Create individual radar plots for each cluster
pdf("Results/BOAT2_Org_Structure_Cluster_Radar_Original_Scales.pdf", width = 20, height = 12)

# K=2 individual radar plots
par(mfrow = c(1, 2))
for(i in 1:2) {
  cluster_data <- rbind(
    max_scales,
    rep(0, ncol(org_structure_data)),
    org_radar_k2 %>% filter(cluster == i) %>% select(-cluster)
  )
  colnames(cluster_data) <- colnames(org_radar_k2_plot)
  create_radar_plot_custom(cluster_data, 
                          paste("Cluster", i, "Organizational Structure (k=2)\nOriginal Scales"),
                          colors_k2[i])
}

# K=3 individual radar plots
par(mfrow = c(1, 3))
for(i in 1:3) {
  cluster_data <- rbind(
    max_scales,
    rep(0, ncol(org_structure_data)),
    org_radar_k3 %>% filter(cluster == i) %>% select(-cluster)
  )
  colnames(cluster_data) <- colnames(org_radar_k3_plot)
  create_radar_plot_custom(cluster_data, 
                          paste("Cluster", i, "Organizational Structure (k=3)\nOriginal Scales"),
                          colors_k3[i])
}

dev.off()

# Print summary statistics
cat("\nSummary Statistics for Each Variable:\n")
print(summary(org_structure_data))

cat("\nCluster Means (K=2):\n")
print(org_radar_k2)

cat("\nCluster Means (K=3):\n")
print(org_radar_k3)

# Save organizational structure radar plot data
write.csv(org_radar_k2, "Results/BOAT2_Org_Structure_Radar_Original_Data_k2.csv", row.names = FALSE)
write.csv(org_radar_k3, "Results/BOAT2_Org_Structure_Radar_Original_Data_k3.csv", row.names = FALSE)
```

```{r k7_analysis_and_radar}
# Set random seed for reproducibility
set.seed(123)

# Perform k=7 K-Prototypes clustering
kproto_k7_result <- kproto(kproto_data_mixed, k = 7, verbose = FALSE)

# Prepare radar plot data for k=7
radar_k7 <- radar_data %>%
  mutate(cluster = factor(kproto_k7_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean))

# Prepare radar plot data format for k=7
radar_k7_plot <- rbind(
  rep(5, ncol(radar_k7) - 1),  # Maximum
  rep(0, ncol(radar_k7) - 1),  # Minimum
  radar_k7 %>% select(-cluster)  # Actual data
)

# Set column names
colnames(radar_k7_plot) <- c(
  "Centralization", "Formalization", "Participation", "Organicity", "Coercion",
  "Technocracy", "Command Culture", "Symbolic Culture", "Rationale Culture", 
  "Generative Culture", "Transactive Culture", "Openness", "Recursiveness", 
  "Risk", "Growth Environment", "Hostile Environment", "Stable Environment"
)

# Create color palette for 7 clusters
colors_k7 <- RColorBrewer::brewer.pal(7, "Set2")

# Create radar plot for k=7
pdf("Results/BOAT2_Radar_Plot_K7.pdf", width = 15, height = 10)

# Combined radar plot for all clusters
par(mfrow = c(1, 1))
radarchart(radar_k7_plot,
           axistype = 1,
           pcol = colors_k7,
           pfcol = alpha(colors_k7, 0.3),
           plwd = 2,
           plty = 1,
           cglcol = "grey",
           cglty = 1,
           axislabcol = "grey",
           caxislabels = seq(0, 5, 1),
           cglwd = 0.8,
           vlcex = 0.8,
           title = "K-Prototypes Clustering Radar Plot (k=7)")
legend("topright", 
       legend = paste("Cluster", 1:7),
       col = colors_k7,
       lwd = 2,
       bty = "n")

# Individual radar plots for each cluster
par(mfrow = c(2, 4))
for(i in 1:7) {
  cluster_data <- rbind(
    rep(5, ncol(radar_k7) - 1),
    rep(0, ncol(radar_k7) - 1),
    radar_k7 %>% filter(cluster == i) %>% select(-cluster)
  )
  colnames(cluster_data) <- colnames(radar_k7_plot)
  radarchart(cluster_data,
             axistype = 1,
             pcol = colors_k7[i],
             pfcol = alpha(colors_k7[i], 0.3),
             plwd = 2,
             plty = 1,
             cglcol = "grey",
             cglty = 1,
             axislabcol = "grey",
             caxislabels = seq(0, 5, 1),
             cglwd = 0.8,
             vlcex = 0.8,
             title = paste("Cluster", i, "Characteristics (k=7)"))
}

dev.off()

# Save k=7 clustering results
write.csv(radar_k7, "Results/BOAT2_Radar_Plot_Data_k7.csv", row.names = FALSE)

# Print cluster sizes
cat("\nK=7 cluster sizes:\n")
print(table(kproto_k7_result$cluster))

# Create organizational structure radar plot for k=7
org_radar_k7 <- org_structure_data %>%
  mutate(cluster = factor(kproto_k7_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean))

# Save organizational structure data for k=7
write.csv(org_radar_k7, "Results/BOAT2_Org_Structure_Radar_Data_k7.csv", row.names = FALSE)

# Create organizational structure radar plots for k=7
pdf("Results/BOAT2_Org_Structure_Radar_K7.pdf", width = 15, height = 10)

# Combined plot
par(mfrow = c(1, 1))
org_structure_k7_plot <- rbind(
  apply(org_structure_data, 2, max),  # Maximum values
  apply(org_structure_data, 2, min),  # Minimum values
  org_radar_k7 %>% select(-cluster)   # Cluster means
)
colnames(org_structure_k7_plot) <- c("Employees", "Locations", "Departments", "Layers")

radarchart(org_structure_k7_plot,
           axistype = 1,
           pcol = colors_k7,
           pfcol = alpha(colors_k7, 0.3),
           plwd = 2,
           plty = 1,
           cglcol = "grey",
           cglty = 1,
           axislabcol = "grey",
           cglwd = 0.8,
           vlcex = 0.8,
           title = "Organizational Structure by Cluster (k=7)")
legend("topright", 
       legend = paste("Cluster", 1:7),
       col = colors_k7,
       lwd = 2,
       bty = "n")

# Individual plots
par(mfrow = c(2, 4))
for(i in 1:7) {
  cluster_data <- rbind(
    apply(org_structure_data, 2, max),
    apply(org_structure_data, 2, min),
    org_radar_k7 %>% filter(cluster == i) %>% select(-cluster)
  )
  colnames(cluster_data) <- c("Employees", "Locations", "Departments", "Layers")
  
  radarchart(cluster_data,
             axistype = 1,
             pcol = colors_k7[i],
             pfcol = alpha(colors_k7[i], 0.3),
             plwd = 2,
             plty = 1,
             cglcol = "grey",
             cglty = 1,
             axislabcol = "grey",
             cglwd = 0.8,
             vlcex = 0.8,
             title = paste("Cluster", i, "Organizational Structure (k=7)"))
}

dev.off()
```

```{r k7_statistics_table}
# Load required packages
library(gridExtra)
library(grid)
library(gtable)

# Calculate cluster sizes
k7_cluster_sizes <- table(kproto_k7_result$cluster)

# Create cluster size data frame
cluster_size_df <- data.frame(
  Cluster = paste("Cluster", 1:7),
  Size = as.numeric(k7_cluster_sizes)
)

# Calculate mean values for ordinal variables
k7_ordinal_means <- kproto_data %>%
  mutate(cluster = factor(kproto_k7_result$cluster)) %>%
  group_by(cluster) %>%
  summarise(across(all_of(ordinal_all_vars), \(x) mean(x, na.rm = TRUE))) %>%
  mutate(Cluster = paste("Cluster", cluster)) %>%
  select(-cluster)

# Round all numeric columns to 2 decimal places
k7_ordinal_means[,-1] <- round(k7_ordinal_means[,-1], 2)

# Create PDF
pdf("Results/BOAT2_K7_Cluster_Statistics.pdf", width = 15, height = 10)

# Function to create table grob
create_table_grob <- function(data, title) {
  # Convert data frame to matrix for table
  mat <- as.matrix(data)
  
  # Create the table
  table <- tableGrob(mat, 
                    rows = NULL,
                    cols = colnames(data),
                    theme = ttheme_minimal(
                      core = list(fg_params = list(fontsize = 8),
                                bg_params = list(fill = c("white", "grey95"))),
                      colhead = list(fg_params = list(fontsize = 8, fontface = "bold")),
                      rowhead = list(fg_params = list(fontsize = 8))
                    ))
  
  # Add title
  title <- textGrob(title, gp = gpar(fontsize = 12, fontface = "bold"))
  
  # Combine title and table
  padding <- unit(0.5, "cm")
  combined <- gtable:::rbind_gtable(
    gtable(widths = unit(1, "null"), heights = unit(1, "cm")),
    table,
    "first"
  )
  combined <- gtable_add_grob(combined, title, 
                             t = 1, l = 1, r = ncol(combined))
  
  return(combined)
}

# Create cluster size table
size_table <- create_table_grob(cluster_size_df, "Table 1: K=7 Cluster Sizes")

# Create means table
means_table <- create_table_grob(k7_ordinal_means, "Table 2: Mean Values of Ordinal Variables by Cluster")

# Arrange tables on the page
grid.newpage()
grid.draw(size_table)

grid.newpage()
grid.draw(means_table)

dev.off()

# Display in console
cat("\nCluster Sizes:\n")
print(cluster_size_df)

cat("\nMean Values of Ordinal Variables by Cluster:\n")
print(k7_ordinal_means)

# Save tables as CSV files for backup
write.csv(cluster_size_df, "Results/BOAT2_K7_Cluster_Sizes.csv", row.names = FALSE)
write.csv(k7_ordinal_means, "Results/BOAT2_K7_Ordinal_Means.csv", row.names = FALSE)
```

```{r k7_pdm_analysis}
# Load required packages
library(ggplot2)
library(dplyr)
library(RColorBrewer)

# Create analysis dataset
pdm_analysis <- data.frame(
  Cluster = factor(kproto_k7_result$cluster),
  PDM_Type = original_data$PDM_Type
)

# 1. Create contingency table
pdm_contingency <- table(pdm_analysis$Cluster, pdm_analysis$PDM_Type)
pdm_percentages <- prop.table(pdm_contingency, margin = 1) * 100

# Convert to data frame for plotting
pdm_plot_data <- as.data.frame.table(pdm_contingency)
names(pdm_plot_data) <- c("Cluster", "PDM_Type", "Count")

pdm_plot_data_pct <- as.data.frame.table(pdm_percentages)
names(pdm_plot_data_pct) <- c("Cluster", "PDM_Type", "Percentage")

# Create visualizations
# 1. Stacked bar chart (absolute numbers)
p1 <- ggplot(pdm_plot_data, aes(x = Cluster, y = Count, fill = PDM_Type)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_brewer(palette = "Set3") +
  labs(title = "Distribution of PDM Types by Cluster (Absolute Numbers)",
       x = "Cluster",
       y = "Number of Cases") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0),
        plot.title = element_text(size = 12, face = "bold"))

# 2. Stacked bar chart (percentages)
p2 <- ggplot(pdm_plot_data_pct, aes(x = Cluster, y = Percentage, fill = PDM_Type)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_brewer(palette = "Set3") +
  labs(title = "Distribution of PDM Types by Cluster (Percentages)",
       x = "Cluster",
       y = "Percentage") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0),
        plot.title = element_text(size = 12, face = "bold"))

# 3. Mosaic plot
# Save mosaic plot to PDF
pdf("Results/BOAT2_K7_PDM_Mosaic.pdf", width = 10, height = 8)
mosaicplot(pdm_contingency,
           main = "Mosaic Plot of Clusters vs PDM Types",
           color = brewer.pal(length(unique(pdm_analysis$PDM_Type)), "Set3"),
           xlab = "Cluster",
           ylab = "PDM Type")
dev.off()

# Save bar plots to PDF
pdf("Results/BOAT2_K7_PDM_Distribution.pdf", width = 12, height = 10)
print(p1)
print(p2)
dev.off()

# Perform chi-square test
chi_test <- chisq.test(pdm_contingency)

# Create summary tables
# 1. Absolute numbers
pdm_summary_abs <- as.data.frame.matrix(pdm_contingency)
pdm_summary_abs$Total <- rowSums(pdm_summary_abs)

# 2. Percentages
pdm_summary_pct <- as.data.frame.matrix(pdm_percentages)
pdm_summary_pct <- round(pdm_summary_pct, 2)

# Save results
write.csv(pdm_summary_abs, "Results/BOAT2_K7_PDM_Distribution_Absolute.csv")
write.csv(pdm_summary_pct, "Results/BOAT2_K7_PDM_Distribution_Percentage.csv")

# Print results
cat("\nDistribution of PDM Types by Cluster (Absolute Numbers):\n")
print(pdm_summary_abs)

cat("\nDistribution of PDM Types by Cluster (Percentages):\n")
print(pdm_summary_pct)

cat("\nChi-square Test Results:\n")
print(chi_test)

# Calculate Cramer's V
cramer_v <- sqrt(chi_test$statistic / (sum(pdm_contingency) * (min(dim(pdm_contingency)) - 1)))
cat("\nCramer's V:", round(cramer_v, 3), "\n")

# Create a more detailed summary table
cluster_summary <- data.frame(
  Cluster = paste("Cluster", 1:7),
  Size = as.numeric(table(pdm_analysis$Cluster)),
  Dominant_PDM = apply(pdm_percentages, 1, function(x) names(which.max(x))),
  Dominant_PDM_Percentage = apply(pdm_percentages, 1, max)
)

# Print detailed summary
cat("\nCluster Summary:\n")
print(cluster_summary)

# Save detailed summary
write.csv(cluster_summary, "Results/BOAT2_K7_Cluster_PDM_Summary.csv", row.names = FALSE)
```



